// --------------------------Authentication-------------------
// Authentication is the process of verifying the identity of users or entities attempting to access a system or resource. It ensures that users are who they claim to be before granting access to protected data or functionalities.

// -------------------------Methods of Authentication--------------
// Basic Authentication: Uses a username and password sent as plain text over HTTP. It is simple but lacks security as credentials are not encrypted.

// Token-Based Authentication: Uses tokens (e.g., JWTs - JSON Web Tokens) for authentication. Tokens are generated by the server upon successful login and sent to the client, which includes them in subsequent requests. Tokens are often signed to verify their authenticity.

// Session-Based Authentication: Stores session information on the server and sends a session identifier (usually a cookie) to the client upon successful login. The server uses this identifier to validate requests and maintain session state.


// --------------------------types of authentication methods-------------------

// 1. Password-Based Authentication
// Description: Users provide a username and password to verify their identity.
// Usage: Commonly used for web applications, email services, and internal systems.
// Security Considerations:
// Passwords should be securely stored using hashing algorithms (e.g., bcrypt).
// Use HTTPS to encrypt passwords during transmission.


// 2. Token-Based Authentication
// Description: Users obtain a token (e.g., JWT - JSON Web Token) after successful login, which is sent with subsequent requests for authentication.
// Usage: Widely used in stateless applications and APIs where session management is not desired.
// Security Considerations:
// Tokens should be securely stored and transmitted.
// Tokens can have an expiry time to mitigate risks if leaked.


// 3. Biometric Authentication
// Description: Uses unique physical characteristics (e.g., fingerprints, facial recognition) for user identification.
// Usage: Commonly found in mobile devices (e.g., fingerprint scanners) and secure facilities.
// Security Considerations:
// Requires specialized hardware and software.
// Privacy concerns regarding biometric data storage and usage.


// 4. Multi-Factor Authentication (MFA)
// Description: Requires users to present two or more different authentication factors (e.g., password + SMS code) to gain access.
// Usage: Provides an extra layer of security for sensitive applications and accounts.
// Security Considerations:
// Enhances security by requiring multiple proofs of identity.
// Users may find MFA more cumbersome than single-factor methods.

// 5. OAuth and OpenID Connect
// Description: OAuth is an authorization framework that allows third-party services to access resources without sharing passwords. OpenID Connect extends OAuth to provide authentication services.
// Usage: Used by applications that integrate with external services (e.g., social logins).
// Security Considerations:
// Provides secure delegated access without sharing user credentials.
// Requires careful implementation to prevent authorization flaws.

// 6. Certificate-Based Authentication
// Description: Uses digital certificates issued by a trusted third party to authenticate users or devices.
// Usage: Commonly used in enterprise environments and for secure communication between servers.
// Security Considerations:
// Requires management of certificates and private keys.
// Provides strong authentication for sensitive systems and data.


// 7. Single Sign-On (SSO)
// Description: Allows users to authenticate once and gain access to multiple applications or services without re-entering credentials.
// Usage: Streamlines user experience and reduces password fatigue in organizations with multiple systems.
// Security Considerations:
// Centralized authentication increases the impact of a compromised SSO system.
// Requires careful configuration and monitoring to maintain security.

// 8. api authentication

// --------------------------Autherization-------------------
// Authorization in the context of web applications refers to the process of determining what actions an authenticated user is allowed to perform within the application or system. It follows authentication and ensures that users have appropriate permissions to access resources or perform operations. Here are some common types of authorization methods with examples:

// 1. Role-Based Access Control (RBAC)
// Description: Assigns permissions to users based on roles (e.g., admin, user) defined by the system administrator.
// Example:
// In an e-commerce application:
// Roles: admin, customer
// Permissions:
// admin can add/delete products, manage orders, and access all functionalities.
// customer can view products, add items to cart, and place orders.
// Example middleware for role-based authorization
function isAdmin(req, res, next) {
    if (req.user && req.user.role === 'admin') {
      return next(); // Allow access to admin functionalities
    }
    res.status(403).json({ message: 'Unauthorized' });
  }
  
  app.post('/products', isAdmin, (req, res) => {
    // Only admins can add products
    // Logic to add a product
  });




// 2. Attribute-Based Access Control (ABAC)
// Description: Grants access based on attributes of the user, the resource being accessed, and current environmental factors.
// Example:
// In a healthcare application:
// Attributes: user.age, resource.confidentiality_level, environment.location
// Policy: Allow access to medical records if user.age >= 18, resource.confidentiality_level <= user.security_clearance, and environment.location == 'hospital'.
// Example middleware for attribute-based authorization
function canAccessMedicalRecords(req, res, next) {
    const { age } = req.user;
    const { confidentiality_level } = req.resource;
  
    if (age >= 18 && confidentiality_level <= req.user.security_clearance) {
      return next(); // Allow access to medical records
    }
    res.status(403).json({ message: 'Unauthorized' });
  }
  
  app.get('/medical-records/:id', canAccessMedicalRecords, (req, res) => {
    // Logic to fetch and return medical records
  });

  

// 3. Role-Based Dynamic Access Control (RDAC)
// Description: Combines RBAC with dynamic policies that can change based on specific conditions or user attributes.
// Example:
// In a financial application:
// Roles: manager, employee
// Dynamic Policy: Allow manager to approve transactions over a certain amount, while employee can only view transactions.
// Example middleware for role-based dynamic authorization
function canApproveTransaction(req, res, next) {
    if (req.user && req.user.role === 'manager' && req.transaction.amount > 1000) {
      return next(); // Allow manager to approve high-value transactions
    }
    res.status(403).json({ message: 'Unauthorized' });
  }
  
  app.put('/transactions/:id/approve', canApproveTransaction, (req, res) => {
    // Logic to approve transaction
  });

  

// 4. Policy-Based Access Control (PBAC)
// Description: Defines access control policies explicitly, allowing fine-grained control over permissions based on specific rules or conditions.
// Example:
// In a content management system:
// Policy: Users can edit their own posts but require admin approval to delete any post.
// Example middleware for policy-based authorization
function canDeletePost(req, res, next) {
    if (req.user && (req.user.id === req.post.authorId || req.user.role === 'admin')) {
      return next(); // Allow author or admin to delete post
    }
    res.status(403).json({ message: 'Unauthorized' });
  }
  
  app.delete('/posts/:id', canDeletePost, (req, res) => {
    // Logic to delete a post
  });
  